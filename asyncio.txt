import asyncio
import aiohttp
import aiomysql
import random
import time
import functools
import time
import socket
from multiprocessing import Process, Pool
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from functools import partial


# deco ##############################################################################
def timed(func):
    @functools.wraps(func)
    def wrap(*args):
        start = time.monotonic()
        res = func(*args)
        total = time.monotonic() - start
        print(f'{func.__name__}: {total:.4f} sec')
        return res
    return wrap


def async_timed():
    def wrapper(func):
        '''
        Применяя декоратор «wraps» к нашей внутренней функции, мы копируем имя, 
        строку документации и сигнатуру функции в нашу внутреннюю функцию! 
        (func.__name__, func.__doc__, help(func))
        '''
        @functools.wraps(func)
        async def wrapped(*args, **kwargs):
            start = time.monotonic()
            try:
                return await func(*args, **kwargs)
            finally:
                end = time.monotonic()
                total = end - start
                print(f'{func.__name__}: {total:.4f} sec')
        return wrapped
    return wrapper
###################################################################################################


###################################################################################################
# Ввод/вывод — это чтение или запись данных при работе с неким ресурсом.
# Эти операции медленны в сравнении со скоростью, с которой выполняются вычисления в процессоре.
# В результате эти операции часто называют блокирующими задачами ввода/вывода.
# Приёмы асинхронного программирования используются, в основном, в системах, предусматривающих 
# применение неблокирующих операций ввода/вывода.
# Неблокирующий ввод/вывод — это когда программа запрашивает у системы чтение или запись неких данных,
# и вызывающей стороне не нужно ждать завершения операции перед переходом к другим задачам.
# Операции чтения и записи выполняются тем или иным образом, а сведения о состоянии операций и/или данные, 
# полученные в ходе их выполнения, вызывающая сторона получает позднее, как только они будут готовы, 
# или когда вызывающая сторона готова будет их принять.
###################################################################################################


###################################################################################################
# Асинхронный вызов функции — это запрос на вызов функции, выполняемый неким образом в некий момент времени, 
# при этом вызывающая сторона, после выполнения вызова, может продолжать работу и решать другие задачи.
###################################################################################################


####################################################################################################
# Объект awaitable - это объект, который, в какой-то момент времени может ничего полезного не делать, 
# а заниматься только ожиданием каких-то результатов от сторонних сервисов (например ответа сервера 
# с результатами на свой запрос). Такие объекты всегда запускаются с оператором await.
# Есть три основных типа объектов ожидания awaitable, которые можно запускать оператором await 
# в асинхронном коде:
#   - Корутина (coroutine, сопрограмма) — это функция, выполнение которой может быть приостановлено
#     и возобновлено. Корутины могут самостоятельно приостанавливать и возобновлять своё выполнение 
#     много раз до возврата значения и выхода. Это - функция, определенная с оператором async, может 
#     ждать результаты от сторонних сервисов или своей очереди выполнения. Их можно также использовать 
#     с оператором await внутри других сопрограмм. Корутина способна вызывать другие корутины.
#   
#   - Задача task - это сопрограмма, которая планируются для выполнения в будущем, как только это 
#     станет возможным. Задачи (asyncio.Task) используются для одновременного планирования запуска 
#     нескольких сопрограмм. Запуск задачи всегда происходит оператором await, т. к. она будет ждать 
#     своего выполнения. Асинхронная задача: этот термин используется для обозначения сущности, 
#     представляющей собой объединение асинхронного вызова функции и порождённого этим вызовом 
#     объекта Future.
#
#   - Объект будущих результатов future - объект уже запущенной сопрограммы с еще неполученными
#     промежуточными результатами. Представляет специальный низкоуровневый объект, который хранит 
#     промежуточное состояние запущенной задачи (когда она что-то ожидает) и в будущем, будет 
#     представлять конечный результат асинхронной операции. Этот объект может хранить информацию 
#     о том, что задача ещё не выполнена или не до конца выполнена, или может хранить уже полученный 
#     результат, или исключение, полученное во время выполнения кода.
###################################################################################################


###################################################################################################
# async def func(n):
#     return n*n
# '''
#     asyncio.run(cor)
#     1. создает новое событие
#     2. выполняет корутину
#     3. останавливает и закрывает цикл событий
#     4. является главной входной точкой приложения asyncio
#     5. корутина, которую выполняет asyncio.run, должна создать и запустить все прочие корутины
#     Функция asyncio.run() всегда создает новый цикл событий и в конце его закрывает. 
#     Её следует использовать в качестве основной точки входа для программ с использованием 
#     модуля asyncio, а в идеале функцию asyncio.run() следует вызывать только один раз. 
#
# '''
# result = asyncio.run(func(4))
# print(result)
####################################################################################################


####################################################################################################
# async def func(n):
#     return n*n
# '''
#     Истинное достоинство asyncio – возможность приостановить выполнение и дать циклу событий 
#     возможность выполнить другие задачи, пока длительная операция делает свое дело. Слово async 
#     определяет сопрограмму, а слово await приостанавливает ее на время выполнения длительной операции. 
#     Кроме того, выражение await приостанавливает объемлющую сопрограмму до того момента, как 
#     сопрограмма,  которую  мы  ждем,  завершится  и  вернет  результат. А после этого мы получим 
#     доступ к возвращенному результату, а объемлющая сопрограмма пробудится и обработает результат.
# '''
# async def main():
#     print(await func(4))
#     print(await func(5))

# asyncio.run(main())
#####################################################################################################


#####################################################################################################
# async def func(mes):
#     n = random.randint(1, 10)
#     await asyncio.sleep(n)
#     print(f'{mes} -> {n} сек.')
# '''
#     Чтобы выполнить код конкурентно нужны задачи.
#     Задача – это обертка вокруг сопрограммы, которая планирует выполнение последней в цикле событий 
#     как можно раньше. И планирование, и выполнение происходят в неблокирующем режиме, т.е., 
#     создав задачу, можно сразу приступить к выполнению другого кода, пока эта задача работает в фоне.
#     Задача не будет запущена до тех пор, пока у цикла событий не появится возможность её запустить.
#     Это произойдёт тогда, когда все другие корутины перестанут выполняться и настанет очередь интересующей 
#     нас задачи.
#     asyncio.create_task(corutine) - создание задачи и немедленное добавление в цикл событий.
#     Объект задачи всегда следует запускать с оператором await.
#
#     Завершено ли выполнение задачи, можно проверить, воспользовавшись методом task.done().
#     Отменено ли выполнение задачи, можно проверить с помощью метода task.cancelled().
#     Получить результат выполнения задачи можно с помощью метода task.result().
#     Необработанное исключение можно получить, воспользовавшись методом задачи task.exception().
#     Отменить выполнение запланированной задачи можно, воспользовавшись методом task.cancel().
#     Задачу можно оснастить коллбэком, вызываемым при её завершении, воспользовавшись методом 
#     task.add_done_callback(handle).
#     Удалять или отменять регистрацию коллбэков можно, воспользовавшись методом 
#     task.remove_done_callback().
#     Текущую выполняемую задачу можно получить посредством метода asyncio.current_task().
#     Можно получить набор объектов всех запланированных и выполняющихся (ещё не завершённых) задач 
#     с помощью функции asyncio.all_tasks()
# '''
# async def main():
#     start = time.perf_counter()

#     task1 = asyncio.create_task(func('fun1'))
#     task2 = asyncio.create_task(func('fun2'))
#     task3 = asyncio.create_task(func('fun3'))

#     await task1
#     await task2
#     await task3

#     end = time.perf_counter()
#     print(f'Итого {round(end-start,0)} сек.')

# asyncio.run(main())
#######################################################################################################


#######################################################################################################
# async def func(mes):
#     n = random.randint(1, 10)
#     await asyncio.sleep(n)
#     print(f'{mes} -> {n} сек.')
# '''
#    Сбор задач в коллекцию
#    Асинхронный запуск создаваемых задач можно планировать при помощи функции asyncio.gather()
#    Для конкурентного выполнения допускающих ожидание объектов широко используется функция asyncio.gather.
#    Она принимает последовательность допускающих ожидание объектов и запускает их конкурентно.
#    Если среди объектов есть сопрограмма, то gather автоматически обертывает ее задачей, чтобы 
#    гарантировать конкурентное выполнение.
#    asyncio.gather возвращает объект, допускающий ожидание. Если использовать его в выражении await, то 
#    выполнение будет приостановлено, пока не завершатся все переданные объекты. А когда это произойдет, 
#    asyncio.gather вернет список результатов работы.
#    однострочный вариант запуска задач и получения результатов
#         results = await asyncio.gather(coro_1(), coro_2())
# '''
#
#  async def main():
#    tasks = []
#    for i in range(1, 11):
#        tasks.append(asyncio.create_task(func(f'func{i}'))
#
#    await asyncio.gather(*tasks)
#   
#  asyncio.run(main())
#######################################################################################################


##########################################################################################################
# async def fetch_status(session, url):
#     async with session.get(url) as result:
#         return result.status
   
# @async_timed() 
# async def main():
#     async with aiohttp.ClientSession() as session:
#         urls = ['https://example.com' for _ in range(1000)]
#         urls_2 = ['brocken url' for _ in range(1000)]
#         urls.extend(urls_2)
#         requests = [fetch_status(session, url) for url in urls]
#         '''
#         asyncio.gather принимает необязательный параметр, return_exceptions, который позволяет указать, 
#         как мы хотим обрабатывать исключения от допускающих ожидание объектов.
#         return_exceptions=False – это режим по умолчанию. Если хотя бы одна сопрограмма возбуждает исключение,
#         то gather возбуждает то же исключение в точке await. Но, даже если какая-то сопрограмма откажет, 
#         остальные не снимаются и продолжат работать при условии, что мы обработаем исключение и оно не 
#         приведет к остановке цикла событий и снятию задач;
#         return_exceptions=True – в этом случае исключения возвращаются в том же списке, что результаты. 
#         Сам по себе вызов gather не возбуждает исключений, и мы можем обработать исключения, как нам удобно.
#         '''
#         status_codes = await asyncio.gather(*requests, return_exceptions=True)
#         return status_codes

# res = asyncio.get_event_loop().run_until_complete(main())   # for windows !
# print(res)
###########################################################################################################


###########################################################################################################
# '''
#     У asyncio.gather есть недостаток – необходимость дождаться завершения всех допускающих ожидания объектов,
#     прежде чем станет возможен доступ к результатам.
#     Функция as_completed принимает список допускающих ожидание объектов и возвращает итератор по будущим 
#     объектам. Эти объекты можно перебирать, применяя к каждому await. Когда выражение await вернет управление, 
#     мы получим результат первой завершившейся сопрограммы.
#     Функция asyncio.as_completed() запускает и ждет выполнения переданных в нее задач/awaitable-объектов, 
#     и как только появляются результаты у какой-нибудь задачи, в реальном времени, начинает возвращать их в 
#     итераторе. Результаты извлекаются, запуском каждого объекта итератора при помощи оператора await:
#         for coro in as_completed(aws):
#             earliest_result = await coro
#             ... 
# '''
# @async_timed()
# async def get_response(session, url):
#     delay = random.randint(1, 10)
#     await asyncio.sleep(delay)
#     async with session.get(url) as result:
#         return result.status
    
# @async_timed()
# async def main(num_req):
#     new_session = aiohttp.ClientSession()
#     async with new_session as session:
#         reqs = [get_response(session, 'https://www.example.com') for _ in range(1, num_req+1)]
#         for finish_req in asyncio.as_completed(reqs, timeout=3):
#             try:
#                 result = await finish_req
#                 print(result)
#             except asyncio.TimeoutError:
#                 print('Timeout')

# asyncio.get_event_loop().run_until_complete(main(20))   # for windows !
# #asyncio.run(main(3))
###########################################################################################################


#######################################################################################################
# async def func(mes):
#     n = random.randint(1, 10)
#     await asyncio.sleep(n)
#     print(f'{mes} -> {n} сек.')
# '''
#    Асинхронно запустить задачи можно при помощи функции asyncio.wait()
#    The main differences between the gather() and wait() functions are as follows:
#      - wait() takes an iterable of tasks, whereas gather() takes separate expressions 
#        and does not support an iterable as an argument.
#      - gather() returns an awaitable (e.g. an asyncio.Future) whereas wait() is a coroutine function.
#      - wait() can be configured in terms of the condition it is waiting for, whereas the gather() 
#        function will only return when all tasks are done.
#      - wait() supports a timeout, whereas gather() does not.
#      - gather() supports coroutines and tasks, whereas wait() only supports tasks as arguments.
#      - gather() returns an iterable of results from coroutines and tasks, whereas wait() returns 
#        sets of done and not done tasks.
# '''
#
#  async def main():
#    tasks = []
#    for i in range(1, 11):
#        tasks.append(asyncio.create_task(func(f'func{i}'))
#
#    await asyncio.wait(tasks)
#   
#  asyncio.run(main())
#######################################################################################################


###########################################################################################################
# '''
#   done, pending = asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)
#   Функция wait() одновременно запускает awaitable-объекты из переданного множества aws и производит 
#   блокировку выполнения программы до выполнения условия, указанного в аргументе return_when.
#   Возвращает кортеж из двух множеств Task/Future в виде (done, pending):
#        done, pending = await asyncio.wait(aws)
#   Первое множество содержит все объекты задач, соответствующие условию. Второе содержит все остальные 
#   объекты задач, то есть те, которые условию не соответствуют.
#   asyncio.wait() не вызывает исключение asyncio.TimeoutError. 
#   Задачи, которые не успели выполнится по истечении timeout, приостанавливают свое выполнение 
#   и возвращаются во втором множестве pending. В последствии, можно возобновить выполнение приостановленных 
#   задач.
#   asyncio.FIRST_COMPLETED	Функция возвратит результат, когда любой из Future завершится или был отменен.
#   asyncio.FIRST_EXCEPTION	Функция возвратит результат, когда любой из Future завершится созданием исключения. 
#                           Если никакое Future не вызывает исключения, то эта константа эквивалентна asyncio.ALL_COMPLETED.
#   asyncio.ALL_COMPLETED	Функция возвратит результат, когда все Future завершатся или будут отменены.
#   В отличие от функции asyncio.wait_for(), asyncio.wait() не отменяет, а приостанавливает задачи при наступлении таймаута.
# '''
#
# async def get_response(session, url):
#     delay = random.randint(1, 10)
#     await asyncio.sleep(delay)
#     async with session.get(url) as result:
#         return result.status
    
# @async_timed()
# async def main(num_req):
#     new_session = aiohttp.ClientSession()
#     async with new_session as session:
#         reqs = [get_response(session, 'https://www.example.com') for _ in range(1, num_req+1)]
#         reqs_2 = [get_response(session, 'broken') for _ in range(1, num_req+1)]
#         reqs.extend(reqs_2)
#         random.shuffle(reqs)

#         all_done = 0
#         while reqs:
#             #done, reqs = await asyncio.wait(reqs, return_when=asyncio.FIRST_COMPLETED)
#             done, reqs = await asyncio.wait(reqs, timeout=3)
#             all_done += len(done)
#             print(f'\nall_done: {all_done}')
#             print(f'now done: {len(done)}')
#             print(f'now wait: {len(reqs)}')
 
#             for d in done:
#                 if d.exception() is None:
#                     print(f'Success in {d.get_name()} Result: {d.result()}')
#                 else:
#                     print(f'Error in {d.get_name()}')

# asyncio.get_event_loop().run_until_complete(main(100))   # for windows !
###########################################################################################################



###########################################################################################################
# '''
#     asyncio.wait_for(coroutine, timeout) - принимает объект сопрограммы или задачи и тайм-аут в 
#     секундах и возвращает сопрограмму, к которой можно применить await. Если задача не завершилась 
#     в отведенное время, то возбуждается исключение TimeoutError и задача автоматически снимается.
#
#		try:
#			# ожидание завершения задачи
#			await asyncio.wait_for(coro, timeout=1)
#		except asyncio.TimeoutError:
#			# ...
#		except Exception:
#			# ...
#
#     Если необходимо избежать отмены задачи, необходимо обернуть ее в функцию asyncio.shield().
# '''
# async def task_coro(arg):
#    value = 1 + random()
#    print(f'>task got {value}')
#    await asyncio.sleep(value)
#    print('>task done')
# 
# async def main():
#    task = task_coro(1)
#    
#    try:
#        await asyncio.wait_for(task, timeout=0.2)
#    except asyncio.TimeoutError:
#        print('Gave up waiting, task canceled')
# 
# asyncio.run(main())
###########################################################################################################



###########################################################################################################
# async def func(name, secs):
#     n = random.randint(1, secs)
#     await asyncio.sleep(n)
#     print(f'{name} -> {n} сек.')


# async def main(num_task, secs):
#     start = time.perf_counter()

#     tasks = []
    
#     for i in range(1, num_task+1):
#         task = asyncio.create_task(func(f'fun_{i}', secs))
#         tasks.append(task)
    
#     for task in tasks:
#         await task

#     end = time.perf_counter()
#     print(f'Итого {round(end-start,0)} сек.')
# '''
#     Мы можем создать цикл событий, воспользовавшись методом asyncio.new_event_loop. 
#     Он возвращает экземпляр цикла событий, который дает доступ ко всем низкоуровневым методам, 
#     в частности методу run_until_complete, который принимает сопрограмму и исполняет ее до 
#     завершения. Закончив работу с циклом событий, мы должны закрыть его, чтобы освободить 
#     занятые ресурсы. Обычно это делается в блоке finally, чтобы цикл был закрыт даже в случае 
#     исключения.
# '''
# loop = asyncio.new_event_loop()
# try:
#     loop.run_until_complete(main(num_task=30, secs=15))
# finally:
#     loop.close()
###########################################################################################################


###########################################################################################################
# Цикл событий - это ядро любого приложения на основе модуля asyncio. Объект цикла событий, своими методами 
# запускает асинхронные задачи и обратные вызовы, выполняют сетевые операции ввода-вывода, а так же запускают 
# подпроцессы. Выполняется в единственном потоке.
#
# Следующие низкоуровневые функции могут использоваться для получения, установки или создания цикла событий:
# asyncio.get_running_loop() - возвращает запущенный цикл событий в текущем потоке ОС. 
# Если нет запущенного цикла событий, вызывается RuntimeError. Функция может вызвана только 
# из корутины или обратного вызова.
#
# asyncio.get_event_loop() - получает текущий цикл событий. Если в текущем основным потоке ОС 
# не установлен текущий цикл событий, а set_event_loop() ещё не был вызван, asyncio создаст 
# новый цикл событий и установит его как текущий. Поскольку у функции сложное поведение 
# (особенно при использовании настраиваемых политик цикла событий), вызов функции get_running_loop() 
# лучше, чем get_event_loop() в корутинах и обратных вызовах.
#
# asyncio.set_event_loop(loop) - устанавливает loop как текущий цикл событий для текущего потока ОС.
#
# asyncio.new_event_loop() - создает новый объект цикла событий.
#
# Методы, связанные с запуском и остановкой цикла событий:
# - loop.run_until_complete() запускает цикл событий до завершения сопрограммы,
# - loop.run_forever() запускает цикл событий до явной остановки,
# - loop.stop() останавливает цикл событий,
# - loop.is_running() проверяет, запущен ли цикл событий,
# - loop.is_closed() проверяет, закрыт ли цикл событий,
# - loop.close() закрывает цикл событий,
# - loop.shutdown_asyncgens() закрывает асинхронные генераторы,
# - loop.shutdown_default_executor() закрывает исполнитель по умолчанию
#
# Пример запуска и остановки цикла событий низкоуровневым API.
# loop = asyncio.get_event_loop()
#    try:
#        # создаем задачи 
#        task1 = loop.create_task(cor_1())
#        task2 = loop.create_task(cor_2())
#        # объединяем задачи в группу, для планирования асинхронного выполнения
#        group =  asyncio.gather(task1, task2)
#        # получаем результаты
#        return_value = loop.run_until_complete(group)
#       print(f'Результаты работы сопрограмм: {return_value}')
#    finally:    
#        # останавливаем цикл событий
#        loop.close()
#
# Методы низкоуровнего API цикла событий, позволяющие планировать обратные вызовы:
# - loop.call_soon() планирует обратный вызов на следующей итерации цикла событий,
# - loop.call_soon_threadsafe() потокобезопасный обратный вызов,
# - loop.call_later() планирует обратный вызов с задержкой,
# - loop.call_at() планирует обратный вызов в определенное время,
# - loop.time() возвращает текущее время,
# - asyncio.Handle - дескриптор обратного вызова
#
# Методы низкоуровнего API цикла событий, позволяющие создавать задачи и объекты будущих результатов:
# - loop.create_future() создает объект Future,
# - loop.create_task() создает объект Task,
# - loop.set_task_factory() устанавливает фабрику задач,
# - loop.get_task_factory() получает фабрику задач
###########################################################################################################


###########################################################################################################
# Может возникнуть соблазн использовать существующие библиотеки ввода-вывода, обернув их сопрограммами. 
# Однако при этом возникнут проблемы, что и для счетных операций. Эти API будут блокировать главный поток. 
# Поэтому, попытавшись выполнить блокирующий вызов API в сопрограмме, мы заблокируем сам поток цикла событий, 
# а значит, воспрепятствуем выполнению всех остальных сопрограмм и задач. Примерами блокирующих API является 
# библиотека requests или функция time.sleep. Вообще, любая функция, которая выполняет ввод-вывод, не являясь 
# сопрограммой, или занимает процессор длительными операциями, может считаться блокирующей.
# Для запуска из асинхронного кода функций, которые могут блокировать ход выполнения программы используйте 
# subprocesses или функцию asyncio.to_thread() или функцию loop.run_in_executor().
# Функция asyncio.to_thread(func, *args, **kwargs) асинхронно запускает блокирующую цикл событий функцию func 
# в отдельном потоке. Любые *args и **kwargs, переданные в функции asyncio.to_thread(), напрямую передаются в
# запускаемую func. Возвращает сопрограмму, для которой можно ожидать результаты функции func.
#
#	def func(i):
#		n = random.randint(2, 10)
#		time.sleep(n)
#		print(f'func {i} - {n} sec')
#
#
#	async def main(nums_funcs):
#		tasks = []
#		for i in range(nums_funcs):
#			tasks.append(asyncio.create_task(asyncio.to_thread(func, i)))
#
#		await asyncio.gather(*tasks)
#
#
#	if __name__ == '__main__':
#		asyncio.run(main(10))
###########################################################################################################



###########################################################################################################
# Эхо сервер (tcp)
# - loop.create_server(protocol_factory, host=None, port=None, *, family=socket.AF_UNSPEC, 
#                      flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None, 
#                      reuse_port=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, 
#                      start_serving=True)
# Метод loop.create_server() создает TCP-сервер (сокет типа SOCK_STREAM), прослушивающий порт port адреса host.
# Метод loop.create_server() представляет собой сопрограмму и возвращает объект Server.
#
# Серверные объекты asyncio.Server - это асинхронные диспетчеры контекста. 
#    srv = await loop.create_server(...)
#    async with srv:
#        ...
#
# Методы и атрибуты объекта Server:
# - Server.close() останавливает обслуживание сервера,
# - Server.get_loop() возвращает цикл событий сервера,
# - Server.start_serving() начинает принимать подключения,
# - Server.serve_forever() начинает принимать соединения,
# - Server.is_serving() проверяет, принимает ли сервер соединения,
# - Server.wait_closed() ждет завершения метода,
# - Server.sockets список объектов сокетов.
#
# - loop.create_connection(protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, 
#                          sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, 
#                          ssl_shutdown_timeout=None, happy_eyeballs_delay=None, interleave=None) 
#                         
# Метод loop.create_connection() открывает TCP соединение с заданным адресом, указанным host и port,
# попытается установить соединение в фоновом режиме. В случае успеха - возвращает пару (transport, protocol).
###########################################################################################################



###########################################################################################################
# Методы работы с объектами сокетов 
# - loop.sock_recv() получает до n байтов, возвращает полученные данные в виде байтового объекта,
# - loop.sock_recv_into() получает данные в буфер,
# - loop.sock_recvfrom() получает дейтаграмму размером до bufsize от sock,
# - loop.sock_recvfrom_into() получает дейтаграмму размером до n байт из sock в buf,
# - loop.sock_sendall() отправляет данные, продолжает отправку в сокет до тех пор, пока не будут отправлены 
#                       все данные data или пока не возникнет ошибка. В случае успеха ничего не возвращается. 
#                       При ошибке возникает исключение.
# - loop.sock_sendto() отправляет дейтаграмму из sock на address,
# - loop.sock_connect() подключается к удаленному сокету,
# - loop.sock_accept() принимает соединение, сокет должен быть привязан к адресу и прослушивать соединения. 
#                      Возвращаемое значение - это пара (conn, address), где conn - это новый объект сокета, 
#                      который можно использовать для отправки и получения данных в соединении, а address - 
#                      это адрес, привязанный к сокету на другом конце соединения.
# - loop.sock_sendfile() отправляет файл. Аргумент file должен быть обычным файловым объектом, открытым в 
#                        двоичном режиме mode='rb'.
#
# Эхо сервер (socket)
# async def echo(client_sck, loop):
#     req = None
#     while req != 'quit':
#         data = await loop.sock_recv(client_sck, 1024)
#         req = data.decode('utf-8', 'ignore')
#         resp = req
#         if req == '/help':
#             resp = 'help service activated'
#         await loop.sock_sendall(client_sck, bytes(resp, 'utf-8'))
#     client_sck.close()
#
# async def listen_connection(server_sck, loop):
#     while True:
#         client_sck, address = await loop.sock_accept(server_sck)
#         client_sck.setblocking(False)
#         print(f"Client: {address}")
#         asyncio.create_task(echo(client_sck, loop))
#
# async def main():
#     server_sck = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#     server_sck.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
#     server_address = ('127.0.0.1', 9001)
#     server_sck.setblocking(False)
#     server_sck.bind(server_address)
#     server_sck.listen()
#     print(f'Start server ...')
#     await listen_connection(server_sck, asyncio.get_event_loop())
#
# asyncio.run(main())
###########################################################################################################


###########################################################################################################
# Неблокирующие потоки
# В модуле asyncio имеются средства для работы с неблокирующими сокетами ввода/вывода. 
# Эти средства представлены потоками.
# Для открытия клиентского TCP-соединения с использованием asyncio-сокета можно прибегнуть к функции 
# asyncio.open_connection().
#
# asyncio.open_connection(host=None, port=None, *, limit=None, ssl=None, family=0, proto=0, flags=0, 
# sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, 
# happy_eyeballs_delay=None, interleave=None)
#
# asyncio.open_connection() - корутина, устанавливает сетевое соединение и возвращает пару объектов 
# (reader, writer). Эти объекты являются экземплярами классов StreamReader и StreamWriter, которые позволяют 
# взаимодействовать с сокетом.
#
# Открыть asyncio-сокет, на котором будет основана работа TCP-сервера, можно, воспользовавшись функцией 
# asyncio.start_server().
#
# asyncio.start_server(client_connected_cb, host=None, port=None, *, limit=None, family=socket.AF_UNSPEC, 
# flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, 
# ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)
#
# Функция возвращает объект asyncio.Server, представляющий работающий сервер.
#
# client_connected_cb вызывается каждый раз, когда устанавливается новое соединение с клиентом. 
# Эта функция принимает пару объектов (reader, writer) в виде двух аргументов. Эти объекты представляют собой 
# экземпляры классов StreamReader и StreamWriter. Будет вызываться каждый раз, когда клиент подключается к 
# серверу.
#
# пример:
# функция для обработки клиентских подключений
# async def handler(reader, writer):
#     ...
#
# запуск сервера, предназначенного для приёма HTTP-соединений
# server = await asyncio.start_server(handler, '127.0.0.1', 80)
#
# 
# запись байтового представления данных
# writer.write(byte_data)
# ожидание завершения передачи данных
#  await writer.drain()
#
# чтение байтового представления данных
# byte_data = await reader.read()
#




###########################################################################################################
# В библиотеке aiohttp и вообще при работе с веб-запросами используется понятие сеанса. 
# Внутри сеанса хранится много открытых подключений, их можно при необходимости использовать повторно.  
# Это называется пулом подключений и играет важную роль в производительности приложений на базе aiohttp. 
# Сеанс также самостоятельно сохраняет все полученные куки.В большинстве приложений на базе aiohttp
# создается один сеанс для всего приложения. Затем объект сеанса передается методам. У объекта сеанса  
# имеются методы для отправки веб-запросов, в том числе GET, PUT и POST. Для создания сеанса используется 
# синтаксис async with и асинхронный контекстный менеджер aiohttp.ClientSession.
###########################################################################################################


###########################################################################################################
# отправка веб запроса
# Для создания сеанса используется синтаксис async with и
# асинхронный контекстный менеджер aiohttp.ClientSession.
# async def fetch_status(session, url):
#     timeout = aiohttp.ClientTimeout(total=1)
#     async with session.get(url, timeout=timeout) as result:
#         return result.status
#
# async def main():
#     timeout = aiohttp.ClientTimeout(total=1,  connect=1)
#     async with aiohttp.ClientSession(timeout=timeout) as session:
#         url = 'https://www.example.com'
#         status = await fetch_status(session, url)
#         print(f'Состояние для {url} - {status}')
#
# asyncio.get_event_loop().run_until_complete(main())  # for windows !
#asyncio.run(main())
###########################################################################################################


###########################################################################################################
# async def fetch_status(session, url):
#     async with session.get(url) as result:
#         return result.status
#  
# @async_timed() 
# async def main():
#     async with aiohttp.ClientSession() as session:
#         urls = ['https://example.com' for _ in range(1000)]
#         requests = [fetch_status(session, url) for url in urls]
#         status_codes = await asyncio.gather(*requests)
#         print(status_codes)
# 
# asyncio.get_event_loop().run_until_complete(main())   # for windows !
# #asyncio.run(main())
###########################################################################################################



##########################################################################################################
# Basic
# async def main():
#     connection = await aiomysql.connect(host='127.0.0.1', 
#                                           port=3306, 
#                                           db='namedb', 
#                                           user='username', 
#                                           password='pass')
    
#     cur = await connection.cursor()

#     ...

#     await cur.close()
#     connection.close()

# asyncio.run(main())
###########################################################################################################


##########################################################################################################
# loop = asyncio.get_event_loop()

# async def test_example():
#     conn = await aiomysql.connect(host='127.0.0.1', port=3306,
#                                   user='root', password='',
#                                   db='mysql', loop=loop)

#     # create default cursor
#     cursor = await conn.cursor()

#     # execute sql query
#     await cursor.execute("SELECT Host, User FROM user")

#     # fetch all results
#     r = await cursor.fetchall()

#     # detach cursor from connection
#     await cursor.close()

#     # close connection
#     conn.close()

# loop.run_until_complete(test_example())
###########################################################################################################



###########################################################################################################
# Пул - механизм для создания нескольких подключений и управления ими. В пуле находится конечное число 
# подключений, которые можно захватывать по мере необходимости. Пулы обеспечивают повторное использование 
# подключений. Иными словами, если мы захватываем подключение из пула для выполнения запроса, то после 
# завершения запроса подключение «освобождается», т. е. возвращается в пул.

# loop = asyncio.get_event_loop()

# async def go():
#     pool = await aiomysql.create_pool(host='127.0.0.1', port=3306,
#                                       user='root', password='',
#                                       db='mysql', loop=loop, autocommit=False)

#     async with pool.acquire() as conn:
#         async with conn.cursor() as cur:
#             await cur.execute("SELECT 10")
#             # print(cur.description)
#             (r,) = await cur.fetchone()
#             assert r == 10
#     pool.close()
#     await pool.wait_closed()

# loop.run_until_complete(go())
###########################################################################################################

###########################################################################################################
# Если требуется выполнить счетную работу (cpu) и использовать async / await, то это можно сделать. Но 
# придется воспользоваться многопроцессностью и попросить asyncio выполнять наши задачи в пуле процессов!
###########################################################################################################

#######################################################################################################
# I/O операции, блокирующие цикл событий можно запустить в пуле потоков, а операции, связанные с процессором, 
# которые так же могут заблокировать цикл событий - в пуле процессов.
# - loop.run_in_executor(executor, cor, *args) запускает функцию в указанном исполнителе,
# - loop.set_default_executor() устанавливает исполнителя по умолчанию
#
# пример
#
# import asyncio
# import concurrent.futures
#
# def blocking_io():
#    # Файловые операции(например, ведение журнала) могут
#    # блокировать цикл событий: запустим их в пуле потоков.
#    with open('/dev/urandom', 'rb') as f:
#        res = f.read(100)
#        return res
#
# def cpu_bound():
#    # Операции, связанные с процессором, заблокируют цикл событий:
#    # в общем случае предпочтительно запускать их в пуле процессов.
#    return sum(i * i for i in range(10 ** 7))
#
# async def main():
#    loop = asyncio.get_running_loop()
#
#    # Запуск в исполнителе по умолчанию:
#    result = await loop.run_in_executor(None, blocking_io)
#    print('\nПул потоков (по умолчанию):', result)
#
#    # Запуск в пользовательском пуле потоков:
#    with concurrent.futures.ThreadPoolExecutor() as pool:
#        result = await loop.run_in_executor(pool, blocking_io)
#        print('\nЯвно установленный пул потоков:', result)
#
#   # Запуск в настраиваемом пуле процессов:
#    with concurrent.futures.ProcessPoolExecutor() as pool:
#        result = await loop.run_in_executor(
#            pool, cpu_bound)
#        print('\nПользовательский пул процессов:', result)
#
#if __name__ == '__main__':
#    asyncio.run(main())
#######################################################################################################


#######################################################################################################
# Модуль multiprocessing тоже предоставляет пулы воркеров, использующие процессы и потоки, посредством 
# классов Pool и ThreadPool.
#
# from multiprocessing.pool import Pool
# import random
#
# def func(i):
#     return i**i
#
# results = []
# def main(num_procs):
#     pool = Pool()
#     for _ in range(num_procs):
#         results.append(pool.apply_async(func, args=(random.randint(1, 10),)))
#     pool.close()
#     pool.join()
# 
#     for r in results:
#         print(r.get(timeout=1))
#
# if __name__ == '__main__': 
#     main(5)
#######################################################################################################



# 19 #
def count(n):
    s = 0
    for i in range(n): 
        s += i**n
    return s

@timed
def main1(proc_num, n):
    for _ in range(proc_num):
        count(n)

@timed
def main2(proc_num, n):
    procs = []
    for _ in range(proc_num):
        procs.append(Process(target=count, args=(n,)))

    for proc in procs:
        proc.start()

    for proc in procs:
        proc.join()


@timed
def main3(proc_num, n): 
    with Pool() as procs_pool:
        tasks = []
        for _ in range(proc_num):
            tasks.append(procs_pool.apply_async(count, args=(n,)))
        results = []
        for task in tasks:
            results.append(task.get())


@timed
def main4(proc_num, n):
    l = [n for _ in range(proc_num)]
    with ProcessPoolExecutor() as procs_pool:
        procs_pool.map(count, l)


@async_timed()
async def main5(proc_num, n):
    with ProcessPoolExecutor() as procs_pool:
        loop = asyncio.get_running_loop()
        calls = [partial(count, n) for _ in range(proc_num)]
        
        cors = []
        for call in calls:
            cors.append(loop.run_in_executor(procs_pool, call))
        
        await asyncio.gather(*cors)



if __name__ == '__main__':
    a, b = 5, 7000
    main1(a, b)
    main2(a, b)
    main3(a, b)
    main4(a, b)
    asyncio.run(main5(a, b))
