1)
    Контейнеры (containers) представляют собой средства инкапсуляции приложения вместе с его зависимостями.
Контейнеры совместно используют ресурсы основной ОС, тогда как целью применения виртуальной машины 
является полная эмуляция ОС. Для каждой виртуальной машины необходимы полная копия ОС, запускаемое приложение 
и все библиотеки поддержки.
    Контейнеры Docker упрощают перемещение (перенос) программных приложений. Разработчики могут полностью 
сосредоточиться на создании приложения, на проведении цикла тестирования и на вводе приложения в эксплуатацию, 
не беспокоясь о различиях в программных средах и обеспечении необходимых зависимостей.
    Простота  и  высокая  скорость  работы  контейнеров  позволяют  считать  их  наиболее подходящими 
компонентами для реализации архитектуры микросервисов.

Docker-compose — это утилита, позволяющая запускать одновременно несколько контейнеров, используя при этом 
единый файл конфигурации всего стека сервисов, нужных вашему приложению. 


2) установка
    - для Windows установить Docker Desktop

    $ sudo usermode -aG docker              добавление пользователя в группу docker (можно вводить команды без sudo)

    $ sudo service docker restart           перезапуск сервиса docker

    docker info                 информация о системе Docker

    docker version              версия системы Docker



3)

    docker run -it debian:latest                            загрузка образа debian версии latest (если нет) + запуск НОВОГО контейнера в интерактивной среде

    docker run -d debian:latest                             загрузка образа debian версии latest (если нет) + запуск НОВОГО контейнера в фоновом режиме

    docker run -h <hosname> -it debian:latest               загрузка образа debian версии latest (если нет) + запуск НОВОГО контейнера в интерактивной среде
                                                            с указанием имени хоста

    docker run --name <container_name> -it debian:latest    загрузка образа debian версии latest (если нет) + запуск НОВОГО контейнера в интерактивной среде
                                                            с указанием имени контейнера
    
    docker run --rm -it debian:latest                       загрузка образа debian версии latest (если нет) + запуск НОВОГО контейнера в интерактивной среде,
                                                            после остановки контейнера - он удаляется

    docker run -d -p 8000:8000 nginx                        запуск контейнера c перенаправлением 8000 порта хоста на 8000 контейнера

    docker run -d --name redmine_app -p 3737:3000 redmine_app          запуск нового контейнер в фоне с проброской портов хоста на контейнер (localhost:3737 --> redmin:3000)

    ID=$(docker run -d -P nginx)
    docker port $ID 80                                      автоматически выбор свободного порта на хосте, проброс его на 80 порт контейнера

    docker port  <container_name>                           порт назначенный Docker



4) контейнер

    docker ps                                   работающие контейнеры
    docker ps -a                                все контейнеры
    docker ps -aq                               идентификаторы всех контейнеров

    docker inspect <container_name>             информация о контейнере

    docker diff <container_name>                список файлов измененных в контейнере

    docker logs <container_name>                список всех событий контейнера

    docker create <image>                       создание контейнера из образа
    
    docker start <container_name / hash>                    запуск контейнера

    docker stop <container_name / hash>                     остановка контейнера

    docker rm <container_name / hash>                       удаление контейнера

    docker exec -it <container_name / hash> /bin/bash       подключение к запущенному контейнеру

    docker run -v /data test/ubuntu                         запуск НОВОГО контейнера от образа test/ubuntu и общим c хост машиной каталогом /data

    docker run -it --link mredis:redis debian /bin/bash     запуск НОВОГО контейнера от образа debian и связать (сеть) с контейнером mredis:redis 


5) образ

    docker images                       список локальных образов
    
    docker pull ubuntu:latest                                       скачать образ
                                                                    ( пр. 
                                                                    docker pull amouat/revealjs:latest 
                                                                    загрузит образ с тегом latest в репозиторий amouat/revealjs 
                                                                    из реестра Docker Hub )


    docker commit <container_name> <repo>/<new_image_name>          создание нового образа <repo>/<new_image_name> 
                                                                    из существующего контейнера <container_name>
                                                                    ( пр. docker commit myapp test/debian_mc )


    docker save -o /tmp/redis.tar redis:latest                      сохранение образа в файл

    docker load -i /tmp/redis.tar                                   загрузка репозитория из файла в образ



6) Dockerfile

    Dockerfile – это обычный текстовый файл, содержащий набор операций, которые могут быть использованы для создания Docker-образа.
    Слои в итоговом образе создают только инструкции FROM, RUN, COPY, и ADD. 
    Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно 
    что-то сделать, например — открыть какой-то порт или выполнить какую-то команду.

    --------------------------------------------------------------------------------------------------------------------
    пр. Dockerfile

    #                   комментарий

    FROM debian:latest                                                      определение базового образа ОС (image:tag)
    LABEL                                                                   описание метаданных (кто создал и поддерживает образ)
    MAINTAINER John Smith <john@smith.com>                                  информация об авторе

    RUN apt-get update && apt-get upgrade && apt-get install -y mc          запуск команд
    COPY <source_file> <destination_file>                                   копирование файл хоста (из контекста создания) в образ
    VOLUME /data                                                            общий с хостом каталог, объявляет заданный файл или каталог как том

    ADD                 копирует файлы (из контекста создания) в создаваемый образ (архивы распаковываются)
    CMD                 описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен
                        (CMD ["python", "identidock.py"] - двойные кавычки, формат json)
                        В одном файле Dockerfile может присутствовать лишь одна инструкция CMD.
    ENTRYPOINT          определяет выполняемый файл (программу) (и аргументы по умолчанию), запускаемый при инициализации контейнера
    ENV <var> <value>   определяет переменные среды внутри образа
    EXPOSE              сообщает механизму Docker о том, что в данном контейнере будет существовать процесс, прослушивающий заданный 
                        порт или несколько портов. Механизм Docker использует эту информацию при установлении соединения между контейнерами 
                        или при открытии портов для общего доступа при помощи аргумента -P в команде docker run
                        Инструкция EXPOSE указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться
                        с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить 
                        перенаправление портов, нужно выполнить команду docker run с ключом -p. Если использовать ключ в виде -P (с заглавной буквой P),
                        то открыты будут все порты, указанные в инструкции EXPOSE.
    ONBUILD             определяет инструкцию, которая должна выполняться позже, когда данный образ будет использоваться как основной 
                        уровень для другого образа. Это может оказаться полезным при обработке данных, добавляемых в образ-потомок.
    USER                задает пользователя (по имени или по UID) для использования во всех последующих инструкциях RUN, CMD, ENTRYPOINT
    WORKDIR             определяет рабочий каталог для всех последующих инструкций RUN, CMD, ENTRYPOINT, ADD, COPY
    ARG                 задает переменные для передачи Docker во время сборки образа
                        (В отличие от ENV-переменных, ARG-переменные недоступны во время выполнения контейнера)
    --------------------------------------------------------------------------------------------------------------------


    docker build -t <repo>/<new_image_name>:<tag> .         создание образа, выполнить команду в каталоге с подготовленным Dockerfile
                                                            Точка в конце команды указывает на то, что образ надо собрать с использованием 
                                                            файла Dockerfile, находящегося в текущей рабочей директории.
                                                            Размещение файла Dockerfile внутри контекста может быть указано с помощью 
                                                            аргумента -f (например, docker build -f docker/Dockerfile.debug .)





    docker run -d -p 5000:5000 -v "$(pwd)"/app:/app newapp      # Аргумент -v "$(pwd)"/app:/app позволяет смонтировать подкаталог app из текущего 
                                                                рабочего каталога хоста на каталог /app внутри контейнера. Старое содержимое 
                                                                каталога /app контейнера заменяется новым, при этом сохраняется возможность 
                                                                записи в этот каталог.



7)  
    0. Создаем приложение, например на Flask.

    1. В каталоге приложения создать Dockerfile, например:
        
                FROM python:3.11

                RUN pip install flask
                WORKDIR /app
                COPY app /app
                USER user

                CMD ["python", "identidock.py"]

    2. Создать образ

            cd app
            docker build -t <new_image_name> .

    3. Запуск контейнера

            docker run -d -p 5000:5000 app


8) Создание локального реестра

        docker run -d -p 7000:5000 registry:2           теперь можно присваивать образам соответствующие теги 
                                                        и выгружать их в этот реестр
                                                        ( 
                                                            docker tag redis:latest localhost:7000/redis:v01 
                                                            docker push localhost:7000/redis:v01
                                                        )
        Также перезапустить каждый демон Docker, которому требуется доступ к созданному реестру, с аргументом 
        --insecure-registry 192.168.1.100:7000 (нужно указать адрес и номер порта удаленного реестра).



--------------
9) 
    Docker позволяет использовать 5 режимов сети:
    
        bridge -            программный режим моста. Docker по умолчанию использует сеть с названием bridge для всех контейнеров 
                            для общения в пределах одного хоста, если для них не описываются другие сети.
                            Можно сделать свою сеть данного типа и подключать к ней контейнеры. 
                            В docker CLI создать сеть можно командой:
                            
                                    docker network create net_name

        overlay -           распределенная сеть между множественными хостами Docker для использования сервисами.

        host -              изолирует контейнер, к нему можно обращаться только в пределах Docker-хоста.

        none -              отключает все сети.

        macvlan/ipvlan -    позволяет привязать контейнеру MAC-адрес, тем самым позволяет подключиться к физической сети. 
                            Рекомендуется для использования с теми приложениями, что требуют прямого доступа к сети. 
                            Не может использоваться при описании файла конфигурации Docker Compose.

    
    По умолчанию Compose создает единую сеть для приложения. Каждый контейнер сервиса подключается к сети по-умолчанию 
    и доступен другим контейнерам в этой сети, имея хостнейм идентичный имени контейнера.
    Сеть приложения имеет имя по названию директории в которой находится файл описания Compose

        docker network ls                                   список сетей на хосте
        docker network inspect <network_name_or_id>         детализация сети


    
    ex:

        services:
            # sys0:
            #   build:                    # билд нового образа из dockerfile
            #     context: ./folder
            #     dockerfile: Dockerfile
            #   image: new_build_image
            #   ...

            sys1:
                image: django_base:v1
                container_name: sys1
                ports:
                - 7001:80
                networks:
                default:    # external net
                public:     # internal net
                    ipv4_address: 145.145.145.11


            sys2:
                image: django_base:v1
                container_name: sys2
                ports:
                - 7002:80
                networks:
                public:   # only internal net
                    ipv4_address: 145.145.145.22


        networks:
        # internal
        public:
            # external: true    # external имеет флаг true - сеть была создана извне
            # external:
            #   name: my-pre-existing-network   # подключиться к созданной сети
            driver: bridge
            internal: true  # внутренняя сеть, делает сеть изолированной !
            ipam:
            driver: default
            config:
                - subnet: 145.145.145.0/24
                # gateway: 145.145.145.100
        # external
        default:
            driver: bridge