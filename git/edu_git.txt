1)
    В Git файлы могут находиться в одном из трёх состояний:
    - зафиксированном (файл уже сохранён в локальной базе), 
    - изменённом (файлы, которые поменялись, но ещё не были зафиксированы), 
    - подготовленном (это изменённые файлы, отмеченные для включения в следующий коммит).  (add, stage)

    Файлы также могут быть:
    - отслеживаемые (файлы, которые были в последнем commit'е проекта),
    - неотслеживаемые (новые)

    В проекте с использованием Git есть три части:
    - рабочий каталог (working directory),
    - область подготовленных файлов (staging area),
    - каталог Git (Git directory).

    Рабочий каталог — это извлечённая из базы копия определённой версии проекта. Эти
файлы достаются из сжатой базы данных в каталоге Git и помещаются на диск для того, чтобы
вы их просматривали и редактировали.

    Область подготовленных файлов — это обычный файл, хранящийся в каталоге Git, 
который содержит информацию о том, что должно войти в следующий коммит.

    Каталог Git — это место, где Git хранит метаданные и базу данных объектов вашего проекта.

    Каждое состояние репозитория должно быть рабочим !!!

2) Git config
    Установленные параметры могут быть сохранены в трех местах:
        --system  (для всех пользователей системы),
        --global  (для конкретного пользователя),
        без параметра (для конкретного репозитория).
    Настройки на каждом уровне подменяют настройки из предыдущего!

    Первое, что следует сделать после установки Git, ― указать имя и адрес электронной
почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена
в коммиты.

    $ git config --global user.name "Maksim Durov"
    $ git config --global use.email duroff.83@yandex.ru

    Список всех настроек:
    $ git config --list

    $ git config --global core.editor "code --wait"     редактор по умолчанию

    $ git config --global core.autocrlf true            конвертация конца строки из LF в CRLF (для windows при выгрузке)
    $ git config --global core.autocrlf input           конвертировать в LF при коммитах (при загрузки на удаленной репозиторий)




3) Клонирование с глобального репозитория в каталог. (создание локальной копии!)
    ! Git умеет работать с четырьмя сетевыми протоколами для передачи данных: file://, http://, ssh:// и git://

    $ git clone git://github.com/palladine/edu_python.git             клонирование в каталог edu_python
    $ git clone git://github.com/palladine/edu_python.git .           клонирование в текущий каталог
    $ git clone git://github.com/palladine/edu_python.git myfolder    клонирование в каталог myfolder

    $ git clone --depth=5 <url репозитория>             клонирование с глубиной в 5 коммитов


4) Создание репозитория в каталоге проекта (локально)

    $ git init                          инициализация
    $ git add .                         добавление к отслеживанию новых файлов, и подготовка (индексирование) всех файлов к commit'у 
                                        Эта команда добавляет изменения из рабочего каталога в так называемую "staging area". 
                                        Staging area – это промежуточный этап перед созданием коммита.
                                        ($ git add test.txt    только один файл test.txt)
                                        ($ git add /abc/def    все файлы в каталоге) 
    $ git commit -m "comment"           фиксация (Каждый коммит — это снимок состояния проекта в определенный момент времени, 
                                        снабженный уникальным хешем и сообщением, описывающим суть изменений)

    ($ git commit -a -m 'comment'       автоматически индексировать отслеживаемые файлы на момент коммита)



5) Определение состояния файлов.
    $ git status



6) Удаление файла

    $ git rm <filename>                удаление файла из отслеживаемых (из индекса) и с диска (далее провести коммит)
    $ git rm --cached <filename>       удаление файла из индекса, но оставление в рабочем каталоге
                                       (полезно если файл не добавлен в .gitignore и по ошибке проиндексирован)

    $ git filter-branch --tree-filter 'rm -f <filename>' HEAD           удаление файла из каждого снимка состояния (коммита)
                                                                        независимо от того существовал ли он там или нет.
                                                                        Опция --tree-filter выполняет указанную команду после 
                                                                        выгрузки каждой версии проекта и затем заново делает 
                                                                        коммит из результата.

    $ git clean -f                      удаление не отслеживаемых файлов (untracking)


7) Перемещение / переименование файла

    $ git mv <file_from> <file_to>              переименование файла
    $ git mv name_folder/ new_name_folder       переименование каталога 
    $ git mv name_file name_folder              перенос файла в каталог


8) История коммитов

    HEAD (*) - это символическое имя текущего выбранного коммита (ветки) (коммит, над которым мы в данный момент работаем)
    Можно переключать ссылку от ветки, коммита или HEAD:
    ^ или ~1       - на шаг назад (родитель)
    ^^^ или ~3     - на три шага назад (прапрародитель)

    $ git log
    $ git log -1 HEAD             последний коммит
    $ git log -p -2               отображение разницы в дву последних коммитах
    $ git log --stat              краткая информация по каждому коммиту
    $ git log --since=2.weeks     список коммитов за последние две недели

    $ git log --pretty=oneline                       вывод в одну строку каждого коммита 
                                                     (параметры - oneline, short, full, fuller)
    
    $ git log --pretty=format:"%h - %an, %ar : %s"    собственный формат вывода
             %H - Хеш коммита                                    %ad - Дата автора (формат соответствует параметру --date= )
             %h - Сокращенный хеш коммита                        %ar - Дата автора, относительная (пр. "2 мес. назад")
             %T - Хеш дерева                                     %cn - Имя коммитера
             %t - Сокращенный хеш дерева                         %ce - Электронная почта коммитера
             %P - Хеши родительских коммитов                     %cd - Дата коммитера
             %p - Сокращенные хеши родительских коммитов         %cr - Дата коммитера, относительная
            %an - Имя автора                                      %s - Комментарий
            %ae - Электронная почта автора

    $ git log --graph          вывод ASCII граф истории ветвлений

    $ git show <commit_hash>         посмотреть содержимое коммита

    $ git show HEAD@{5}              посмотреть какое значение HEAD имел пять шагов назад для своего репозитория

    $ git show HEAD^  ($ git show HEAD~)   показать родителя HEAD (шаг назад) 

    $ git show HEAD^2                      показать родителя HEAD (два шага назад)

    $ git show HEAD^^^   ($ git show HEAD~3)        показать первого родителя первого родителя первого родителя HEAD (три шага назад)
                                                    (~ переход по первым родителям n раз)

    $ git show HEAD~3^2             (второй родитель от первого прародителя (три шага назад)) (комбинирование обозначений)

    $ git log origin/master..HEAD           все коммиты в текущей ветке которых нет в ветке master на сервере origin


    $ git diff                      изменения относительно последнего коммита (какие изменения внесены после последнего коммита,
                                    но в индекс не добавлены)
    $ git diff HEAD                 изменения от последнего коммита до текущего состояния (даже если в индекс добавлены)
    $ git diff --staged             изменения подготовленные к следующему коммиту
    $ git diff HEAD~1               изменения между двумя последними коммитами (последним и предпоследним)
    $ git diff <commit_hash>        изменения между последним коммитом и коммитом с хешем
    $ git diff <commit_hash_1> <commit_hash2_>      изменения между коммитами



9) Отмена изменений

    На любой стадии может возникнуть необходимость что-либо отменить.

    $ git commit --amend            изменение последнего коммита (т.е. повторить последний коммит еще раз,
                                    перед этим можно внести изменения в индекс, добавить файлы и т.д. !)
                                    (меняет SHA-1 коммита !)

    $ git reset HEAD                отмена последней индексации
    $ git reset HEAD <file>         отмена индексации файла (исключение файла из индекса)
    
    $ git reset --soft HEAD~1       откатить последний коммит, но оставить изменения в рабочем каталоге и индексе
    
    $ git reset HEAD^               отмена последнего коммита и оставление изменённых файлов непроиндексированными 
                                    (--mixed - режим по умолчанию)

    $ git checkout -- <file>
    или
    $ git restore <file>            отменить сделанные изменения в файле, перед индексацией! (вернуть состояние файла из последнего коммита)
                                    Если файл попал в индекс, то вместе с названием команды нужно использовать опцию --staged
                                    ( $ git restore --staged <file> )

    $ git reset --soft <commit_hash>        проект откатывается к указанному коммиту и переводит все последующие коммиты в индекс
    $ git reset --mixed <commit_hash>       проект откатывается к указанному коммиту и откаченные файлы попадают в неотслеживаемую зону, 
                                            эти файлы можно изменить, удалить или вернуть обратно в индекс
    $ git reset --hard <commit_hash>        проект откатывается к указанному коммиту и удаляет все последующие коммиты без возможности их восстановлени

    $ git revert HEAD                       отмена в глобальном репозитории ! 
                                            (создание нового коммита с удалением последних изменений в указанном в комманде коммите)


10) Удаленные репозитории

    $ git remote -v                             список настроенных удаленных репозиториев (origin - сокращение)
    $ git remote show <сокращение>              информация об удаленном репозитории

    $ git remote add <сокращение> <url>         добавление удаленного репозитория (связь локального и удаленного репозиториев)
                                                (пр. $ git remote add pyedu http://github.com/palladine/edu_python.git   
                                                pyedu - сокращение(имя), традиционно называют origin)

    $ git remote rename <old> <new>             переименование сокращенного имени (также меняет имена удалённых веток !)

    $ git remote rm <сокращение>                удаление ссылки на удаленный репозиторий

    $ git fetch <сокращение>                    данная команда связывается с указанным удалённым проектом и забирает все те данные
                                                проекта, которых ещё нет. После выполнения команды, должны появиться ссылки на все ветки 
                                                из этого удалённого проекта. Команда fetch забирает данные в локальный репозиторий,но не 
                                                сливает их с какими-либо наработками и немодифицирует их.
                                                ! (Когда на удаленном и локальном серверах изменения) Для синхронизации вашей работы 
                                                выполняется команда  $ git fetch origin. Эта команда ищет, какому серверу соответствует 
                                                origin; извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное 
                                                хранилище данных; сдвигает указатель origin/master на новую позицию.
    
    $ git pull                                  извлекает (fetch) данные с сервера, с которого изначально были склонированы данные, 
                                                и автоматически пытается слить (merge) их с кодом, над которым в данный момент идет 
                                                работа

    $ git push <сокращение> <branch>            отправка данных (пр. $ git push origin master)
                                                Отправляет локальные коммиты на удаленный репозиторий


        ----------------------------------------------------------------------------
        ! (Когда на удаленном и локальном серверах изменения) !
        при выполнении команды отправки изменения на удаленный сервер
        $ git push origin master
        падает ошибка
        ! [rejected]
        error: failed to push some refs to '...'
        необходимо выполнить
        $ git fetch origin            извлечение изменений с удаленного сервера
        $ git merge origin/master     слияние локальных изменений с удаленными
        если конфликты слияния, решить их командой
        $ git mergetool
        после заккомитить в локальном репозитории
        $ git commit -m '***'
        и отправить на удаленный
        $ git push origin master
        ----------------------------------------------------------------------------



11) Метки

    $ git tag                       просмотреть метки

    Git использует два основных типа меток: легковесные и аннотированные:
        - легковесная — это просто указатель на определённый коммит,
        - аннотированная - хранится в базе данных Git’а как полноценный объект. 
          Имеет контрольную сумму, содержит имя поставившего метку, e-mail, дату, комментарий.

    $ git tag -a <tag_name> -m 'comment'                            создание аннотированной метки tag_name с комментарием

    $ git tag -a <tag_name> <commit_control_sum> -m "comment"       создание аннотированной метки tag_name к определенному коммиту 
                                                                    (указать контрольную сумму коммита, первые 7 цифр)
                                                                    (пр. $ git tag -a v0.2 9fceb02 -m 'v0.2')

    $ git show <tag_name>           просмотр коммита с меткой

    По умолчанию, команда git push не отправляет метки на удалённые серверы. Необходимо явно отправить (push) метки 
на общий сервер после их создания.

    $ git push origin <tag_name>             отправка метки на сервер
    $ git push origin --tags                 отправка всех меток



12) Ветки

    Ветка в Git — это просто легковесный подвижный указатель на один из коммитов.
Имя ветки по умолчанию в Git — master. Ветка указывает на последний сделанный коммит. 
При каждом новом коммите указатель сдвигается вперёд автоматически.

    $ git branch                        список локальных веток (* - текущая ветка)
    $ git branch -a                     список всех веток
    $ git branch --merged               ветки, которые слиты с текущей
    
    $ git branch <branch_name>          создание новой ветки на * указателе (после будет указывать на текущий коммит!)
                                        (текущая ветка отмечается меткой HEAD)

    $ git branch -m <old_branch_name> <new_branch_name>     переименование ветки old_branch_name в new_branch_name
    
    $ git branch <branch_name> <start_point>    создание новой ветки от точки 
                                                (пр. $ git branch devel_branch origin/master)

    $ git checkout <branch_name>/<commit>       переключение на ветку branch_name или коммит commit
                                                (постановка HEAD на ветку или коммит)

    $ git checkout <branch_name>^               переключиться на родителя ветки branch_name, т.е. перенести HEAD !

    $ git checkout -b <branch_name>     создание новой ветки и сразу переключение на нее

    $ git merge <branch_name>           слияние ветки branch_name с текущей веткой (у которой HEAD)
                                        (перейти на ту ветку, в которую необходимо внести изменения и выполнить команду)
                                        (пр. $ git checkout master
                                             $ git merge testing )
    
    $ git merge --no-ff <branch_name>   слить ветку с принудительным созданием merge-коммита
                                        (Опция --no-ff — "no fast-forward" - принудительно создает merge-коммит, 
                                        даже если в главной ветке не было изменений)

    $ git branch -d <branch_name>           удаление ветки branch_name
                                            (нельзя удалить ветку пока она не слита с другой)

    $ git branch -f <branch_name> HEAD~3    переместить ветку branch_name на три родителя назад от HEAD


    $ git switch <branch_name>          переключиться на существующую ветку

    $ git switch -c <branch_name>       создать и переключиться на новую ветку

    $ git switch -                      вернуться на предыдущую ветку

    
    Конфликты слияния.

    $ git status            какие файлы приводят к конфликту (отмечено как unmerged)

    $ git checkout --ours <filename>    оставить изменения их текущей ветки
    $ git checkout --theirs <filename>  оставить изменения из вливаемой ветки
                                        (далее добавление в индекс и новый коммит)

    $ git mergetool         выбор инструмента редактирования конфликтных файлов
                            (после удачного индексирования решенных конфликтов для завершения слияния выполнить 
                            $ git commit -m "comment" )

    $ git merge --abort     отменить попытку слияния

    $ git push <сокращение> <branch_name>          отправка локальной ветки в удаленную ветку

    $ git checkout -b <local_branch_name> <сокращение>/<remote_branch_name>     создание локальной ветки на основе удаленной

    $ git push <сокращение> :<remote_branch_name>             удаление ветки на сервере

    $ git checkout <branch_name_source> 
    $ git rebase <branch_name_destination>                  перемещение текущей ветки с HEAD <branch_name_source> в ветку <branch_name_destination>
    $ git checkout <branch_name_destination>


    $ git checkout <branch_name_3>
    $ git rebase --onto <branch_name_1> <branch_name_2> <branch_name_3>     перемещение ветки <branch_name_3> на ветку <branch_name_1> в обход ветки <branch_name_2>
    $ git checkout <branch_name_1>
    $ git merge <branch_name_3>
                                                                            (<branch_name_2> ветка от <branch_name_1>, <branch_name_3> ветка от <branch_name_2>)



    $ git cherry-pick <commit_hash1, commit_hash2, ...>     перемещение нужного (лучшего) коммита в актуальную ветку (к текущему HEAD).
                                                            Берётся патч, который был представлен в коммите, и делается попытка применить
                                                            его на ветке, на которой вы сейчас находитесь. Это удобно в том случае, если у вас в тематической
                                                            ветке находится несколько коммитов, а вы хотите включить в проект только один из них, или
                                                            если у вас только один коммит в тематической ветке, но вы предпочитаете выполнять отбор
                                                            лучшего вместо перемещения.

    $ git rebase -i HEAD~3                                  вернуться к 3-му коммиту и изменить его


13) Прятанье

    Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые
файлы и изменения в индексе, и сохраняет их в стек незавершённых изменений, которые вы
потом в любое время можете снова применить.

    $ git stash                         спрятать изменения

    $ git stash list                    список спрятанных изменений

    $ git stash apply <stash_name>      показать спрятанное изменение (из списка не удаляется)
                                        ( пр. $ git stash apply stash@{0} ) 

    $ git stash drop <stash_name>       удаление спрятанного изменения из листа

    $ git stash pop                     применить все спрятанные изменения в листе и удалить их

    $ git stash show -p <stash_name> | git apply -R          откат применения спрятанных изменений

    $ git stash branch <branch_name>        создание ветки спрятанных изменений 
                                            (если нужен более простой способ снова потестировать спрятанную работу)
    



14) pull request

    1. Крутой программер создал репозиторий.
    2. Вы сделали форк его репозитория (т.е. скопировали к себе).
    3. Вы сделали какие-то крутые изменения в своём репозитории.
       Теперь если вы хотите, чтобы крутой дядя внёс ваши крутые изменения в свой крутой код. 
       И вы просите, чтобы он взял ваши изменения, т.е. сделал git pull. 
       Это и называется pull request.



