1.
pip install pytest
pip install pytestmock (фикстура mocker)


-----------------------------------------------------------------------------------------------
2.
название файла должно начинаться на test_*** или заканчиваться на _test.py
название функции должно быть написано в нижнем регистре и начинаться с test_***
классы должны начинаться с Test***

pytest запускает все тесты в текущем каталоге и подкаталогах


-----------------------------------------------------------------------------------------------
3. запуск тестов

pytest -v -rA --tb=no
pytest -m markname              # запуск тестов с маркировкой 
                                # (будут запущены тесты, помеченные декоратором @pytest.mark.markname)
pytest @tests_filename.txt      # запуск тестов из файла 
                                # (в файле на каждой строке описаны аргументы запуска)
                                # пр.
                                    tests/test_file.py
                                    tests/test_file.py::TestClass::test_method
                                    -m mark
pytest -x                       # остановка после первого упавшего теста
pytest --maxfail=2              # остановка после первых двух упавших тестов
pytest -vv --durations=10       # список 10 самых медленных тестов
pytest --fixtures               # фикстуры
pytest -p mypluginmodule        # подключение плагина

-----------------------------------------------------------------------------------------------
4. простой тест

    def func(x):
        return x+1

    def test_func():
        assert func(3) == 4


---------------------------------------------------------------
4. Группировка в класс. Каждый тест имеет уникальный экземпляр класса.

    class TestClass:
        def test_func1(self):
            assert 1 == 1
        
        def test_func2(self):
            assert 5 in {1, 3, 5}


----------------------------------------------------------------
5. проверка ожидаемых исключений
    Чтобы убедиться в том, что вызвано ожидаемое исключение, 
    нужно использовать assert в контексте pytest.raises.
    
    def f():
        raise SystemExit(1)


    def test_mytest():
        with pytest.raises(SystemExit):
            f()


-----------------------------------------------------------------------------
6. Параметризация

    # main.py
    def positive_or_negative(x):
    if x > 0:
        return 'positive'
    elif x < 0:
        return 'negative'
    else:
        return 'zero'


    # test
    import pytest
    from main import positive_or_negative
    @pytest.mark.parametrize('x, expected_result',
                            [(165, 'positive'),
                            (1.2, 'positive'),
                            (0.0000001, 'positive'),
                            (-165, 'negative'),
                            (-1.2, 'negative'),
                            (-0.0000001, 'negative'),
                            (0, 'zero')])
    def test_positive_or_negative(x, expected_result):
        assert positive_or_negative(x) == expected_result


-------------------------------------------------------------------------------------------
7.
Фикстуры — это функции, которые создают окружение вокруг тестов. 
Они удобны, когда нужно передать одни и те же входные данные нескольким тестам.

        @pytest.fixture
        def get_prime_nums():
            prime_nums = []
            for num in range(1, 50):
                for div in range(2, num):
                    if num % div == 0:
                        break
                else:
                    prime_nums.append(num)
            return prime_nums

        # тест
        def test_multiply2(get_prime_nums):
            prime_nums = get_prime_nums
            assert multiply2(prime_nums) == [2, 4, 6, 10, 14, 22, 26, 34, 38, 46, 58, 62, 74, 82, 86, 94]


Область действия фикстуры указывается в её декораторе аргументом scope='область действия'. 
Всего есть пять уровней (один вызов фикстуры! для ...):
        'function' — для функции;
        'class' — для класса;
        'module' — для модуля (то есть py-файла) (т.е. каждая функция модуля-файла получит фикстуру);
        'package' — для пакета;
        'session' — для всей сессии тестирования.

        @pytest.fixture(scope='module')
        def get_prime_nums():
            prime_nums = []
            for num in range(1, 50):
                for div in range(2, num):
                    if num % div == 0:
                        break
                else:
                    prime_nums.append(num)
            return prime_nums


При запросе фикстуры функцией! сначала инициализируются фикстуры с самой широкой областью действия
- session и module, а затем - фикстуры более низкого уровня с областями class или function. 
В рамках одной тестовой функции порядок создания фикстур с одинаковой областью действия зависит 
от очередности вызова этих фикстур и установленных между ними зависимостей. При этом фикстуры с 
параметром autouse = True инициализируются прежде явно объявленных фикстур того же уровня.


Финализаторы фикстур. pytest поддерживает выполнение фикстурами специфического завершающего кода 
при выходе из области действия. Если вы используете оператор yield вместо return, то весь код 
после yield выполняет роль «уборщика».

    @pytest.fixture(scope='module')
        def get_prime_nums():
            print('\nРабота фикстуры')
            prime_nums = []
            for num in range(1, 50):
                for div in range(2, num):
                    if num % div == 0:
                        break
                else:
                    prime_nums.append(num)
            yield prime_nums
            print('\nРабота финализатора')   # будет выполнен после последнего теста модуля !





